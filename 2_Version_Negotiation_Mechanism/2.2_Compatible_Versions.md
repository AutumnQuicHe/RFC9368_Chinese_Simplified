---
title: "2.2. 兼容版本协商"
anchor: "2.2_Compatible_Versions"
weight: 220
rank: "h2"
---


如果A、B是两个不同的QUIC版本，A是所谓“兼容”B的，如果其可以识别版本A的首飞包，并将其转换为版本B的首飞包。
例如，如果版本A和B在握手期间的链路镜像及行为上是绝对一致的，但是在握手后不一致，那么A是兼容B的且B也兼容A。
注意，对首飞的转换可能是有损耗的；一些数据，例如QUIC第1版的0-RTT包，可能在转换及随后的重传时被忽略。

版本兼容性不是对称的。
存在版本A兼容版本B但是版本B不兼容版本A的情况。
这可能发生在，例如，如果版本B是版本A的一个严格超集，也即，如果版本A包含流及**流帧**的概念，而版本B包含流及假定的连同**流帧**及**管道帧**的管道概念，那么A兼容B，但是B不兼容A。

注意版本兼容性并不意味着首飞的任何单独可能的实例都将成功转换到其他版本。
如果满足两个条件，则称使用版本A的首飞“兼容”版本B：1、版本A兼容版本B且，2、其定义了首飞对版本B的转换。
例如，如果版本B除了在首飞中引入的版本A不能解析或会忽略的新帧之外其他所有方面与版本A一致，则版本B可能仍然兼容版本A，因为转换对于该帧不被使用的连接可能成功。
在该例中，使用版本B的首飞所携带的该新帧不兼容版本A。

当定义一个新的QUIC版本时，一般假设其不兼容任何其他版本，除非额外指定。
同样地，没有其他版本兼容该新版本除非额外指定。
QUIC实现{{< req_level MUST_NOT >}}能假设不同版本之间是兼容的，除非额外指定。

注意双端可能对两个版本是否兼容持相反意见。
例如，两个版本可能同时被定义，但是却在很久后的第三份文档中被定义为兼容的——在那种场景下，一端可能注意到了该兼容性稳定，而另一端则没有。
